{
	"Ratelimiting Configuration": {
	  "prefix": "ConfigureRatelimiting",
	  "body": [
		"public static void ConfigureRatelimiting(this IServiceCollection services)",
		"{",
		"    services.AddMemoryCache();",
		"    services.AddSingleton<IRateLimitConfiguration, RateLimitConfiguration>();",
		"    services.AddInMemoryRateLimiting();",
		"    services.Configure<IpRateLimitOptions>(options =>",
		"    {",
		"        options.EnableEndpointRateLimiting = true;",
		"        options.StackBlockedRequests = false;",
		"        options.HttpStatusCode = 429;",
		"        options.RealIpHeader = \"X-Real-IP\";",
		"        options.GeneralRules = new List<RateLimitRule>",
		"        {",
		"            new RateLimitRule",
		"            {",
		"                Endpoint = \"*\",",
		"                Period = \"10s\",",
		"                Limit = 2",
		"            }",
		"        };",
		"    });",
		"}"
		],
		"description": "Configures rate limiting using AspNetCoreRateLimit package."
	},
	  "HttpGet Action with ProducesResponseType": {
	  "prefix": "Get",
	  "body": [
		"[HttpGet]",
		"[ProducesResponseType(StatusCodes.Status200OK)]",
		"[ProducesResponseType(StatusCodes.Status400BadRequest)]",
		"public async Task<ActionResult<IEnumerable<${1:nameClass}>>> Get()",
		"{",
		"    var ${2:nameVar} = await unitofwork.${3:nameDbSetContext}.GetAllAsync();",
		"    return mapper.Map<List<$1>>($2);",
		"}"
	  ],
	  "description": "HttpGet Action with ProducesResponseType"
	  },
	  "HttpGet Action with Route and ProducesResponseType": {
	  "prefix": "GetId",
	  "body": [
		"[HttpGet(\"{id}\")]",
		"[ProducesResponseType(StatusCodes.Status200OK)]",
		"[ProducesResponseType(StatusCodes.Status400BadRequest)]",
  
		"public async Task<ActionResult<$1>> Get(int id)",
		"{",
		"    var ${2:nameVar} = await unitofwork.${3:nameDbSetContext}.GetByIdAsync(id);",
		"    if ($2 == null){",
		"       return NotFound();",
		"    }",
		"    return this.mapper.Map<$1>($2);",
		"}"
	  ],
	  "description": "HttpGet Action with Route and ProducesResponseType"
	  },
	  "IGenericRepository": {
	  "prefix": "IGenericRepo",
	  "body": [
		"\tTask<T> GetByIdAsync(int id);",
		"\tTask<IEnumerable<T>> GetAllAsync();",
		"\tIEnumerable<T> Find(Expression<Func<T, bool>> expression);",
		"\tvoid Add(T entity);",
		"\tvoid AddRange(IEnumerable<T> entities);",
		"\tvoid Remove(T entity);",
		"\tvoid RemoveRange(IEnumerable<T> entities);",
		"\tvoid Update(T entity);",
	  ],
	  "description": "Interface for Generic Repository"
	},
	"RepoGenerico": {
	  "prefix": "GenericRepo",
	  "body": [
		"\tprivate readonly InventarioContext _context;",
		"",
		"\tpublic GenericRepositoryA(InventarioContext context)",
		"\t{",
		"\t\t_context = context;",
		"\t}",
		"",
		"\tpublic virtual void Add(T entity)",
		"\t{",
		"\t\t_context.Set<T>().Add(entity);",
		"\t}",
		"",
		"\tpublic virtual void AddRange(IEnumerable<T> entities)",
		"\t{",
		"\t\t_context.Set<T>().AddRange(entities);",
		"\t}",
		"",
		"\tpublic virtual IEnumerable<T> Find(Expression<Func<T, bool>> expression)",
		"\t{",
		"\t\treturn _context.Set<T>().Where(expression);",
		"\t}",
		"",
		"\tpublic virtual async Task<IEnumerable<T>> GetAllAsync()",
		"\t{",
		"\t\treturn await _context.Set<T>().ToListAsync();",
		"\t}",
		"",
		"\tpublic virtual async Task<T> GetByIdAsync(int id)",
		"\t{",
		"\t\treturn await _context.Set<T>().FindAsync(id);",
		"\t}",
		"",
		"\tpublic virtual Task<T> GetByIdAsync(string id)",
		"\t{",
		"\t\tthrow new NotImplementedException();",
		"\t}",
		"",
		"\tpublic virtual void Remove(T entity)",
		"\t{",
		"\t\t_context.Set<T>().Remove(entity);",
		"\t}",
		"",
		"\tpublic virtual void RemoveRange(IEnumerable<T> entities)",
		"\t{",
		"\t\t_context.Set<T>().RemoveRange(entities);",
		"\t}",
		"",
		"\tpublic virtual void Update(T entity)",
		"\t{",
		"\t\t_context.Set<T>()",
		"\t\t\t.Update(entity);",
		"\t}",
	  ],
	  "description": "Snippet for GenericRepositoryA class"
	},
	"GetAllAsync Method": {
	  "prefix": "GetAllAsync",
	  "body": [
		"public virtual async Task<(int totalRegistros, IEnumerable<T> registros)> GetAllAsync(int pageIndex, int pageSize)",
		"{",
		"\tvar totalRegistros = await _context.Set<T>().CountAsync();",
		"\tvar registros = await _context.Set<T>()",
		"\t\t.Skip((pageIndex - 1) * pageSize)",
		"\t\t.Take(pageSize)",
		"\t\t.ToListAsync();",
		"\treturn (totalRegistros, registros);",
		"}"
	  ],
	  "description": "Async method to get paged data from database."
	},
	"ToTable": {
	  "prefix": "to-table",
	  "body": [
		"builder.ToTable(${1});"
	  ],
	  "description": "Snippet for Marca Configuration"
	},
	"PrimaryKey": {
	  "prefix": "PrimaryKey",
	  "body": [
		"builder.HasKey(e => e.Id);"
	  ],
	  "description": "Snippet for Marca Configuration"
	},
	"One Many Configuration": {
	  "prefix": "one-to-many",
	  "body": [
		"builder.HasOne(p => p.$1)",
		".WithMany(p => p.$2)",
		".HasForeignKey(p => p.$3);"
	  ],
	  "description": "Snippet for Marca Configuration"
	},
	"de uno a uno": {
	  "prefix": "one-to-one",
	  "body": [
		"builder.HasOne(e => e.$1)",
		".WithOne(p => p.$2)",
		".HasForeignKey<Jugador>(p => p.$3);"
	  ],
	  "description": "de uno a uno"
	},
	"Creacion de llave Compuesta": {
	  "prefix": "keyCompuesta",
	  "body": [
		"builder",
		".HasMany(p => p.$1)",
		".WithMany(p => p.$2)",
		".UsingEntity<$3>(",
		"  j => j",
		"    .HasOne(pt => pt.$4)",
		"    .WithMany(t => t.$6)",
		"    .HasForeignKey(pt => pt.$7),",
		"  j => j",
		"    .HasOne(pt => pt.$5)",
		"    .WithMany(t => t.$6)",
		"    .HasForeignKey(pt => pt.$8),",
		"  j => ",
		"    {",
		"      j.HasKey(t => new {t.$6, t.$7});",
		"    });"
	  ],
	  "description": "Creacion de llave Compuesta"
	  },
	"Varchar Requerido": {
	  "prefix": "PropertyIsRequired",
	  "body": [
		"builder.Property(p => p.$1)",
		".IsRequired()",
		".HasMaxLength($2);"
	  ],
	  "description": "Snippet for Marca Configuration"
	},
	"Varchar": {
	  "prefix": "Property",
	  "body": [
		"builder.Property(p => p.$1)",
		".HasMaxLength($2);"
	  ],
	  "description": "Snippet for Marca Configuration"
	},
	"PK_NO_AI": {
	  "prefix": "pk-int-no-auto-increment",
	  "body": [
		"builder.HasKey(e => e.$1);",
		"builder.Property(e => e.$1)",
		".ValueGeneratedNever();"
	  ],
	  "description": "Snippet Field Configuration"
	},
	"pk string annotation db": {
	  "prefix": "pk-string",
	  "body": [
		"builder.Property(p => p.$1)",
		".HasAnnotation(\"MySql:ValueGenerationStrategy\", MySqlValueGenerationStrategy.IdentityColumn)",
		".HasMaxLength(${2});"
	  ],
	  "description": "Snippet para configurar propiedad con HasAnnotation y MaxLength"
	},
	"pk string fluent": {
	  "prefix": "pk-string-fluent",
	  "body": [
		"builder.HasKey(e => e.$1);",
		"builder.Property(e => e.$1)",
		".HasMaxLength($2);"
	  ],
	  "description": "Snippet para configurar propiedad con HasAnnotation y MaxLength"
	},
	"las dependencias requeridas para el backend": {
	  "prefix": "Depedencias necesarias",
	  "body": [
		  "/*",
		  "API:",
		  "AspNetCoreRateLimit",
		  "AutoMapper.Extensions.Microsoft.DependencyInjection",
		  "Microsoft.AspNetCore.Authentication.JwtBearer",
		  "Microsoft.AspNetCore.Mvc.Versioning",
		  "Microsoft.AspNetCore.OpenApi",
		  "Microsoft.EntityFrameworkCore.Design",
		  "System.IdentityModel.Tokens.Jwt",
		  "",
		  "DOMINIO:",
		  "FluentValidation.AspNetCore",
		  "itext7.pdfhtml",
		  "Microsoft.EntityFrameworkCore",
		  "",
		  "PERSISTENCIA:",
		  "Microsoft.EntityFrameworkCore",
		  "Pomelo.EntityFrameworkCore.MySql",
		  "*/"
	  ],
	  "description": "las dependencias requeridas para el backend"
	  },
	  "informacion de db Context": {
	  "prefix": "DbContext",
	  "body": [
		  "public DbAppContext(DbContextOptions<DbAppContext> options) : base(options)",
		  "{}",
		  "protected override void OnModelCreating(ModelBuilder modelBuilder)",
		  "{",
		  "base.OnModelCreating(modelBuilder);",
		  "modelBuilder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());",
		  "}",
	    ],
	  "description": "informacion de db Context"
	  },
	  "metodo del dbContext que debe inyectarse en el Program ANTES DEL app": {
	  "prefix": "AddDbContext",
	  "body": [
		  "builder.Services.AddDbContext<ApiContext>(options =>",
		  "{",
		  "    string connectionString = builder.Configuration.GetConnectionString(\"ConexMysql\");",
		  "    options.UseMySql(connectionString, ServerVersion.AutoDetect(connectionString));",
		  "});"
	  ],
	  "description": "metodo del dbContext que debe inyectarse en el Program"
	  },
	  "Configuraciones": {
	  "prefix": "configuration",
	  "body": [
		  ": IEntityTypeConfiguration<$1>",
		  "    {",
		  "        public void Configure(EntityTypeBuilder<$1> builder)",
		  "        {",
		  "            builder.ToTable(\"$2\");",
		  "",
		  "            builder.HasKey(e => e.Id);",
		  "            builder.Property(e => e.Id)",
		  "            .HasMaxLength(3);",
		  "",
		  "            builder.Property(e => e.$3)",
		  "            .IsRequired()",
		  "            .HasMaxLength(50);",
		  "        }",
		  "    }"
	  ],
	  "description": "Configuraciones"
	  },
	  "crear la migracion": {
	  "prefix": "CreateMigrations",
	  "body": [
		  "/* dotnet ef migrations add InitialCreate --project .\\Persistencia\\ --startup-project ./API/ --output-dir ./Data/Migrations",
		  " */"
	  ],
	  "description": "crear la migracion"
	  },
	  "updatear la migracion": {
	  "prefix": "UpdateMigrations",
	  "body": [
		  "/*dotnet ef database update --project ./Persistencia/ --startup-project ./API/",
		  " */"
	  ],
	  "description": "updatear la migracion"
	  },
	  "configuracion": {
	  "prefix": "ConfigureCors",
	  "body": [
		  " public static void ConfigureCors(this IServiceCollection services) =>",
		  "    services.AddCors(options =>",
		  "    {",
		  "        options.AddPolicy(\"CorsPolicy\", builder =>",
		  "        builder.AllowAnyOrigin()",
		  "        .AllowAnyMethod()",
		  "        .AllowAnyHeader());",
		  "    });",
		  ""
	  ],
	  "description": "configuracion"
	  },
	  "metodo Post": {
	  "prefix": "Post",
	  "body": [
		  "[HttpPost]",
		  "[ProducesResponseType(StatusCodes.Status201Created)]",
		  "[ProducesResponseType(StatusCodes.Status400BadRequest)]",
		  "",
		  "public async Task<ActionResult<$1>> Post($1 $2Dto)",
		  "{",
		  "var $2= this.mapper.Map<$4>($2Dto);",
		  "this.unitofwork.$3.Add($2);",
		  "await unitofwork.SaveAsync();",
		  "if($2 == null)",
		  "{",
		  "   return BadRequest();",
		  "}",
		  "$2Dto.Id = $2.Id;",
		  "return CreatedAtAction(nameof(Post), new {id =$2Dto.Id}, $2Dto);",
		  "}"
	  ],
	  "description": "metodo Put"
	  },
	  "metodo Put": {
	  "prefix": "Put",
	  "body": [
		  "[HttpPut(\"{id}\")]",
		  "[ProducesResponseType(StatusCodes.Status200OK)]",
		  "[ProducesResponseType(StatusCodes.Status400BadRequest)]",
		  "[ProducesResponseType(StatusCodes.Status404NotFound)]",
		  "",
		  "public async Task<ActionResult<$1>> Put(int id, [FromBody]$1 $2Dto){",
		  "   if($2Dto== null)",
		  "   {",
		  "       return NotFound();",
		  "   }",
	  "    var $2= this.mapper.Map<$3>($2Dto);",
	  "    unitofwork.$4.Update($2);",
	  "    await unitofwork.SaveAsync();",
	  "    return $2Dto;",
		  "}"
	  ],
	  "description": "metodo Put"
	  },
	  "metodo Delete": {
	  "prefix": "Delete",
	  "body": [
		  "[HttpDelete(\"{id}\")]",
		  "[ProducesResponseType(StatusCodes.Status204NoContent)]",
		  "[ProducesResponseType(StatusCodes.Status404NotFound)]",
		  "public async Task<IActionResult> Delete(int id){",
		  "   var $1= await unitofwork.$2.GetByIdAsync(id);",
		  "   if($1== null)",
		  "   {",
		  "      return NotFound();",
		  "   }",
		  "   unitofwork.$2.Remove($1);",
		  "   await unitofwork.SaveAsync();",
		  "   return NoContent();",
		  "}"
	  ],
	  "description": "metodo Delete"
	  },
	  "Configuracion configuracion en especifico": {
	  "prefix": "ControllerEspecifico",
	  "body": [
		  ": BaseApiController",
		  "{",
		  "    private readonly IUnitOfWork unitofwork;",
		  "    private readonly  IMapper mapper;",
		  "",
		  "    public $1Controller(IUnitOfWork unitofwork, IMapper mapper)",
		  "    {",
		  "        this.unitofwork = unitofwork;",
		  "        this.mapper = mapper;",
		  "    }",
	  "}"
	  ],
	  "description": "Configuracion configuracion en especifico"
	  },
	  "AddAplicacionServices": {
	  "prefix": "AddAplicacionServices",
	  "body": [
		  "public static void AddAplicacionServices(this IServiceCollection services)",
		  "    {",
		  "        //Services.AddScoped<IpaisInterface,PaisRepository>();",
		  "        //Services.AddScoped<ITipoPersona,TipoPeronsaRepository>();",
		  "        ",
		  "        services.AddScoped<IUnitOfWork, UnitOfWork>();",
		  "    }"
	  ],
	  "description": "AddAplicacionServices"
	  },
	  "ConfigureApiVersioning": {
	  "prefix": "ConfigureApiVersioning",
	  "body": [
		  " public static void ConfigureApiVersioning(this IServiceCollection services)",
		  "    {",
		  "        services.AddApiVersioning(options =>",
		  "        {",
		  "            options.DefaultApiVersion = new ApiVersion(1, 0);",
		  "            options.AssumeDefaultVersionWhenUnspecified = true;",
		  "            options.ApiVersionReader = new QueryStringApiVersionReader(\"ver\");",
		  "        });",
		  "    }"
	  ],
	  "description": "ConfigureApiVersioning"
	  },
	  "ConfigureUnitOfWork": {
	  "prefix": "UnitOfWork",
	  "body": [
		  ": IUnitOfWork, IDisposable",
		  "{",
		  "    private readonly $5 context;",
		  "    private $1 $2;",
		  "    public UnitOfWork($5 _context)",
		  "    {",
		  "        context = _context;",
		  "    }",
		  "    public $3 $4",
		  "    {",
		  "        get{",
		  "            if($2== null){",
		  "                $2= new $1(context);",
		  "            }",
		  "            return $2;",
		  "        }",
		  "    }",
		  "    public void Dispose()",
		  "    {",
		  "        context.Dispose();",
		  "    }",
		  "    public async Task<int> SaveAsync()",
		  "    {",
		  "        return await context.SaveChangesAsync();",
		  "    }",
		  "}",
		  ""
	  ],
	  "description": "ConfigureUnitOfWork"
	  },
	  "Configurar Repositorio en especifico": {
	  "prefix": "RepoEspecifico",
	  "body": [
		  ": GenericRepo<$1>, I$1",
		  "{",
		  "    protected readonly $2 _context;",
		  "    ",
		  "    public $1Repository($2 context) : base (context)",
		  "    {",
		  "        _context = context;",
		  "    }",
		  "",
		  "    public override async Task<IEnumerable<$1>> GetAllAsync()",
		  "    {",
		  "        return await _context.$3",
		  "            .Include(p => p.$4)",
		  "            .ToListAsync();",
		  "    }",
		  "",
		  "    public override async Task<$1> GetByIdAsync(int id)",
		  "    {",
		  "        return await _context.$3",
		  "        .Include(p => p.$4)",
		  "        .FirstOrDefaultAsync(p =>  p.Id == id);",
		  "    }"
	  ],
	  "description": "Configurar UnitOfWork en especifico"
	  },
	  "añadir metodo AddAplicacionServices pero con la configuracion para los tokens": {
		  "prefix": "AddAplicacionServicesToken",
		  "body": [
			"public static void AddAplicacionServices(this IServiceCollection services)",
			"        {",
			"            //Services.AddScoped<IpaisInterface,PaisRepository>();",
			"            //Services.AddScoped<ITipoPersona,TipoPeronsaRepository>();",
			"",
			"            services.AddScoped<IPasswordHasher<User>, PasswordHasher<User>>(); ",
			"            services.AddScoped<IUserService, UserService>();",
			"            services.AddScoped<IUnitOfWork, UnitOfWork>();",
			"            services.AddScoped<IAuthorizationHandler, GlobalVerbRoleHandlre>();",
			"        }"
		  ],
		  "description": "añadir metodo AddAplicacionServices pero con la configuracion para los tokens"
		},
		"meto para traer el Nombre": {
		  "prefix": "GetByUsernameAsync",
		  "body": [
			"public async Task<User> GetByUsernameAsync(string username)",
			"        {",
			"            return await _context.Users",
			"            .Include(p => p.Rols)",
			"            .FirstOrDefaultAsync(p =>  p.Username.ToLower() == username.ToLower());",
			"        }"
		  ],
		  "description": "meto para traer el Nombre"
		}
  }
