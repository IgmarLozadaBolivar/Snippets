{	
	"Program Configuration": {
		"prefix": "Program",
		"body": [
			"builder.Services.AddAplicacionServices();",
			"builder.Services.ConfigureRatelimiting();",
			"builder.Services.ConfigureApiVersioning();",
			"Debajo de AddSwaggerGen",
			"builder.Services.AddAutoMapper(Assembly.GetEntryAssembly());",
			"builder.Services.ConfigureCors();"
			"Debajo de DbContext",
			"builder.Services.AddJwt(builder.Configuration);",
			"Debajo de var app = builder.Build();",
			"app.UseMiddleware<ExceptionMiddleware>();",
			"Debajo del Configure CSV",
			"app.UseCors(\"CorsPolicy\");",
			"Debajo de UseHttpsRedirection",
			"app.UseIpRateLimiting();",
			"app.UseAuthentication();"
		],
		"description": "Configure BuilderAddAplicacionServices"
	},
	"Serilog Configuration": {
		"prefix": "Serilog",
		"body": [
			"var logger = new LoggerConfiguration()",
			"				.ReadFrom.Configuration(builder.Configuration)",
			"				.Enrich.FromLogContext()",
			"				.CreateLogger();",
			"builder.Logging.AddSerilog(logger);"
		],
		"description": "Configure Serilog"
	},
	"CSV Configuration": {
		"prefix": "CSV",
		"body": [
			"using (var scope = app.Services.CreateScope())",
			"{",
			"	var services = scope.ServiceProvider;",
			"	var loggerFactory = services.GetRequiredService<ILoggerFactory>();",
			"	try",
			"	{",
			"		var context = services.GetRequiredService<DbAppContext>();",
			"		await context.Database.MigrateAsync();",
			"		await DbAppContextSeed.SeedRolesAsync(context,loggerFactory);",
			"		await DbAppContextSeed.SeedAsync(context,loggerFactory);",
			"	}",
			"	catch (Exception ex)",
			"	{",
			"		var _logger = loggerFactory.CreateLogger<Program>();",
			"		_logger.LogError(ex, \"Ocurrio un error durante la migracion!\");",
			"	}",
			"}"
		],
		"description": "Configure CSV"
	},
	"JWT Configuration": {
		"prefix": "JWT",
		"body": [
			",",
			"\"JWT\":",
			"{",
			"	\"Key\": \"rgfZs3pNboV0hbG6Fat123123123sadasdasd\",",
			"	\"Issuer\": \"MyStoreApi\"",
			"	\"Audience\": \"MyStoreApiUser\"",
			"	\"DurationInMinutes\": 1",
			"}"
		],
		"description": "Configure JWT"
	},	
	"ConexString Configuration": {
		"prefix": "ConexString",
		"body": [
			",",
			"\"ConnectionStrings\":",
			"{",
			"	\"ConexSqlServer\": \"Data Source=localhost\\sqlexpress;Inital Catalog=Db;Integrate Security=true\",",
			"	\"ConexMySql\": \"Server=localhost;User=root;Database=NameDatabase;Password=1122809631;\"",
			"}"
		],
		"description": "Configure connection string"
	},
	"Ratelimiting Configuration": {
		"prefix": "ConfigureRatelimiting",
	  	"body": [
			"public static void ConfigureRatelimiting(this IServiceCollection services)",
			"{",
			"    services.AddMemoryCache();",
			"    services.AddSingleton<IRateLimitConfiguration, RateLimitConfiguration>();",
			"    services.AddInMemoryRateLimiting();",
			"    services.Configure<IpRateLimitOptions>(options =>",
			"    {",
			"        options.EnableEndpointRateLimiting = true;",
			"        options.StackBlockedRequests = false;",
			"        options.HttpStatusCode = 429;",
			"        options.RealIpHeader = \"X-Real-IP\";",
			"        options.GeneralRules = new List<RateLimitRule>",
			"        {",
			"            new RateLimitRule",
			"            {",
			"                Endpoint = \"*\",",
			"                Period = \"10s\",",
			"                Limit = 15",
			"            }",
			"        };",
			"    });",
			"}"
		],
		"description": "Configures rate limiting using AspNetCoreRateLimit package."
	},
		"HttpGet Action with ProducesResponseTyp" : {
		"prefix" : "Get Simple",
		"body" : [
			"[HttpGet]",
			"[ProducesResponseType(StatusCodes.Status200OK)]",
			"[ProducesResponseType(StatusCodes.Status400BadRequest)]",
			"public async Task<ActionResult<IEnumerable<$1>>> Get()",
			"{",
			"	var datos = await unitOfWork.$1s.GetAllAsync();",
			"	return Ok(datos);",
			"}"
		]
	},
		"HttpGetMapping Action with ProducesResponseType": {
		"prefix": "GetMapping",
		"body": [
			"[HttpGet]",
			"[MapToApiVersion(\"1.0\")]",
			"[ProducesResponseType(StatusCodes.Status200OK)]",
			"[ProducesResponseType(StatusCodes.Status400BadRequest)]",
			"public async Task<ActionResult<IEnumerable<$1Dto>>> Get()",
			"{",
			"    var data = await unitOfWork.$1s.GetAllAsync();",
			"    return mapper.Map<List<$1Dto>>(data);",
			"}"
	  	],
	  	"description": "HttpGetMapping Action with ProducesResponseType"
	},
		"HttpGet Simple Action with Route and ProducesResponseType": {
		"prefix": "GetID Simple",
		"body": [
			"[HttpGet(\"{id}\")]",
			"[ProducesResponseType(StatusCodes.Status200OK)]",
			"[ProducesResponseType(StatusCodes.Status400BadRequest)]",
			"public async Task<IActionResult> Get(int id)",
			"{",
		    "	var data = await unitOfWork.$1s.GetByIdAsync(id);",
			"	return Ok(data);",
			"}"
		],
	  	"description": "HttpGetID Simple Action with Route and ProducesResponseType"
	},
		"HttpGetIdMapping Action with Route and ProducesResponseType": {
		"prefix": "GetIdMapping",
		"body": [
			"[HttpGet(\"{id}\")]",
			"[ProducesResponseType(StatusCodes.Status200OK)]",
			"[ProducesResponseType(StatusCodes.Status400BadRequest)]",
			"public async Task<ActionResult<$1Dto>> Get(int id)",
			"{",
			"   var data = await unitOfWork.$1s.GetByIdAsync(id);",
			"   if (data == null){",
			"		return NotFound();",
			"	}",
			"   return mapper.Map<$1Dto>(data);",
			"}"
	  	],
		"description": "HttpGetIdMapping Action with Route and ProducesResponseType"
	},
		"HttpGet Action with Route and ProducesResponseType": {
		"prefix": "Pagination",
		"body": [
			"[HttpGet(\"Pagination\")]",
			"[MapToApiVersion(\"1.1\")]",
			"[ProducesResponseType(StatusCodes.Status200OK)]",
			"[ProducesResponseType(StatusCodes.Status400BadRequest)]",
			"public async Task<ActionResult<Pager<$1Dto>>> GetPagination([FromQuery] Params dataParams)",
			"{",
			"   var datos = await unitOfWork.$1s.GetAllAsync(dataParams.PageIndex, dataParams.PageSize, dataParams.Search);",
			"   var listData = mapper.Map<List<$1Dto>>(datos.registros);",
			"	return new Pager<$1Dto>(listData, datos.totalRegistros, dataParams.PageIndex, dataParams.PageSize, dataParams.Search);",
			"}"
	  	],
		"description": "HttpGetPagination Action with Route and ProducesResponseType"
	},
		"IGenericRepository": {
		"prefix": "IGenericRepo",
		"body": [
			"Task<T> GetByIdAsync(int id);",
			"Task<T> GetByIdAsync(string id);",
			"Task<IEnumerable<T>> GetAllAsync();",
			"IEnumerable<T> Find(Expression<Func<T, bool>> expression);",
			"Task<(int totalRegistros, IEnumerable<T> registros)> GetAllAsync(int pageIndex, int pageSize, string search);",
    		"Task<(int totalRegistros, IEnumerable<T> registros)> GetAllAsync(int pageIndex, int pageSize, int search);",
			"void Add(T entity);",
			"void AddRange(IEnumerable<T> entities);",
			"void Remove(T entity);",
			"void RemoveRange(IEnumerable<T> entities);",
			"void Update(T entity);",
	  	],
	  	"description": "Interface for Generic Repository"
	},
		"RepoGenerico": {
		"prefix": "GenericRepo",
		"body": [
			"private readonly DbAppContext _context;",
			"",
			"public GenericRepo(DbAppContext context)",
			"{",
			"	_context = context;",
			"}",
			"",
			"public virtual void Add(T entity)",
			"{",
				"_context.Set<T>().Add(entity);",
			"}",
			"",
			"public virtual void AddRange(IEnumerable<T> entities)",
			"{",
			"	_context.Set<T>().AddRange(entities);",
			"}",
			"",
			"public virtual IEnumerable<T> Find(Expression<Func<T, bool>> expression)",
			"{",
			"	return _context.Set<T>().Where(expression);",
			"}",
			"",
			"public virtual async Task<IEnumerable<T>> GetAllAsync()",
			"{",
			"	return await _context.Set<T>().ToListAsync();",
			"}",
			"",
			"public virtual async Task<(int totalRegistros, IEnumerable<T> registros)> GetAllAsync(int pageIndex, int pageSize, string _search)",
			"{",
			"	var totalRegistros = await _context.Set<T>().CountAsync();",
			"	var registros = await _context.Set<T>()",
			"		.Skip((pageIndex - 1) * pageSize)",
			"		.Take(pageSize)",
			"		.ToListAsync();",
			"",
			"	return (totalRegistros, registros);",
			"}",
			"public virtual async Task<(int totalRegistros, IEnumerable<T> registros)> GetAllAsync(int pageIndex, int pageSize, int _search)",
			"{",
			"	var totalRegistros = await _context.Set<T>().CountAsync();",
			"	var registros = await _context.Set<T>()",
			"		.Skip((pageIndex - 1) * pageSize)",
			"		.Take(pageSize)",
			"		.ToListAsync();",
			"",
			"	return (totalRegistros, registros);",
			"}",
			"public virtual async Task<T> GetByIdAsync(int id)",
			"{",
			"	return await _context.Set<T>().FindAsync(id);",
			"}",
			"",
			"public virtual Task<T> GetByIdAsync(string id)",
			"{",
			"	return await _context.Set<T>().FindAsync(id);",
			"}",
			"",
			"public virtual void Remove(T entity)",
			"{",
			"	_context.Set<T>().Remove(entity);",
			"}",
			"",
			"public virtual void RemoveRange(IEnumerable<T> entities)",
			"{",
			"	_context.Set<T>().RemoveRange(entities);",
			"}",
			"",
			"public virtual void Update(T entity)",
			"{",
			"	_context.Set<T>().Update(entity);",
			"}",
	  	],
	  	"description": "Snippet for GenericRepositoryA class"
	},
		"PaginationGetAllAsync Method": {
		"prefix": "PaginationGetAllAsync",
		"body": [
			"public override async Task<(int totalRegistros, IEnumerable<$1> registros)> GetAllAsync(int pageIndex, int pageSize, string search)",
			"{",
			"	var query = _context.$1s as IQueryable<$1>;",
			"",
			"	if (!string.IsNullOrEmpty(search))",
			"	{",
			"		query = query.Where(p => p.YourPropertyNotString.ToString().ToLower().Contains(search));",
			"		query = query.Where(p => p.YourPropertyString.ToLower().Contains(search));",
			"	}",
			"",
			"	query = query.OrderBy(p => p.Id);",
			"	var totalRegistros = await query.CountAsync();",
			"	var registros = await query",
			"		.Skip((pageIndex - 1) * pageSize)",
			"		.Take(pageSize)",
			"		.ToListAsync();",
			"",
			"	return (totalRegistros, registros);",
			"}"
	  	],
	  	"description": "PaginationAsync method to get paged data from database."
	},
		"ToTable": {
		"prefix": "to-table",
		"body": [
			"builder.ToTable(${1});"
	  	],
	  	"description": "Nombre de Tabla"
	},
		"DbSet": {
		"prefix": "DbSet",
		"body": [
		  	"public DbSet<${1}> ${1}s { get; set; }"
		],
		"description": "Snippet for DbSet"
	},
		"PrimaryKey": {
		"prefix": "PrimaryKey",
		"body": [
			"builder.HasKey(e => e.Id);"
	  	],
	  	"description": "Llave primaria"
	},
		"PropertyId": {
		"prefix": "PropertyId",
		"body": [
			"builder.Property(f => f.Id)",
			"	.IsRequired()",
			"	.HasMaxLength(3);"
		],
		"description":"PropertyId Configuration"
	},
		"PropertyString": {
		"prefix": "PropertyString",
		"body": [
			"builder.Property(f => f.$1)",
			"	.IsRequired()",
			"	.HasColumnName(\"\")",
			"	.HasComment(\"\")",
			"	.HasColumnType(\"\")",
			"	.HasMaxLength(50);"
		],
		"description":"PropertyString Configuration"
	},
		"1:1 Configuration": {
		"prefix": "one-to-one",
		"body": [
			"builder.HasOne(p => p.$1)",
			"	.WithMany(p => p.$2)",
			"	.HasForeignKey(p => p.$3);"
	  	],
	  	"description": "Relacion 1:1"
	},
		"1:Many Configuration": {
	  	"prefix": "one-to-many",
	  	"body": [
			"builder.HasOne(e => e.$1)",
			"	.WithOne(p => p.$2)",
			"	.HasForeignKey<Jugador>(p => p.$3);"
	  	],
	  	"description": "Relacion 1:Many"
	},
		"Creacion de llave Compuesta": {
	  	"prefix": "KeyCompuesta",
	  	"body": [
			"builder.HasMany(p => p.YourEntity's)",
			".WithMany(p => p.YourEntity's)",
			".UsingEntity<EntityIntermediate>(",
			"",
			"  	j => j",
			"    	.HasOne(pt => pt.YourEntity)",
			"    	.WithMany(t => t.EntityIntermediate)",
			"    	.HasForeignKey(pt => pt.LlavePrimaria),",
			"",
			"  	j => j",
			"   	.HasOne(pt => pt.YourEntity)",
			"   	.WithMany(t => t.EntityIntermediate)",
			"   	.HasForeignKey(pt => pt.LlavePrimaria),",
			"",
			"  	j => ",
			"	{",
			"		j.ToTable(\"NameEntityIntermediate\");",
			"		j.HasKey(t => new {t.LlavesPrimarias, t.LlavesPrimarias});",
			"		j.Property(t => t.YourProperty)",
			"			.IsRequired().",
			"			.HasColumnName(\"\").",
			"			.HasComment(\"\").",
			"			.HasColumnType(\"\").",
			"			.HasMaxLength().",
			"});"
	  	],
	  	"description": "Creacion de llave Compuesta"
	},
		"PK_NO_AI": {
	  	"prefix": "pk-int-no-auto-increment",
	  	"body": [
			"builder.HasKey(e => e.$1);",
			"builder.Property(e => e.$1)",
			"	.ValueGeneratedNever();"
	  	],
	  	"description": "Llave primaria no incrementa"
	},
		"pk string annotation db": {
	  	"prefix": "pk-string",
	  	"body": [
			"builder.Property(p => p.$1)",
			"	.HasAnnotation(\"MySql:ValueGenerationStrategy\", MySqlValueGenerationStrategy.IdentityColumn)",
			"	.HasMaxLength(${2});"
	  	],
	  	"description": "Configurar propiedad con HasAnnotation y MaxLength"
	},
		"las dependencias requeridas para el backend": {
	  	"prefix": "Depedencias necesarias",
	  	"body": [
		  	"API:",
		  	"AspNetCoreRateLimit",
		  	"AutoMapper.Extensions.Microsoft.DependencyInjection",
		  	"Microsoft.AspNetCore.Authentication.JwtBearer",
		  	"Microsoft.AspNetCore.Mvc.Versioning",
		  	"Microsoft.AspNetCore.OpenApi",
		  	"Microsoft.EntityFrameworkCore.Design",
		  	"System.IdentityModel.Tokens.Jwt",
			"Serilog.AspNetCore",
		  	"",
		  	"DOMINIO:",
		  	"FluentValidation.AspNetCore",
		  	"itext7.pdfhtml",
		  	"Microsoft.EntityFrameworkCore",
		  	"",
		  	"PERSISTENCIA:",
			"CsvHelper",
		  	"Microsoft.EntityFrameworkCore",
		  	"Pomelo.EntityFrameworkCore.MySql",
			"Npgsql.EntityFrameworkCore.PostgreSQL",
			"Npgsql.EntityFrameworkCore.PostgreSQL.NodaTime",
			"",
			"SEGURIDAD:",
			"System.IdentityModel.Tokens.Jwt",
			"Microsoft.AspNetCore.Authentication.JwtBearer"
	  	],
	  	"description": "las dependencias requeridas para el backend"
	},
	  	"informacion de db Context": {
	  	"prefix": "DbContext",
	  	"body": [
		  	"public DbAppContext(DbContextOptions<DbAppContext> options) : base(options)",
		  	"{}",
		  	"protected override void OnModelCreating(ModelBuilder modelBuilder)",
		  	"{",
		  	"	base.OnModelCreating(modelBuilder);",
		  	"	modelBuilder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());",
		  	"}",
	    ],
	  	"description": "informacion de db Context"
	},
	  	"metodo del dbContext que debe inyectarse en el Program ANTES DEL app": {
	  	"prefix": "AddDbContext",
	  	"body": [
		  	"builder.Services.AddDbContext<DbAppContext>(options =>",
		  	"{",
		  	"    string connectionString = builder.Configuration.GetConnectionString(\"ConexMysql\");",
		  	"    options.UseMySql(connectionString, ServerVersion.AutoDetect(connectionString));",
		  	"});"
	  	],
	  	"description": "metodo del dbContext que debe inyectarse en el Program"
	},
	  	"crear la migracion": {
	  	"prefix": "CreateMigrations",
	  	"body": [
		  	"dotnet ef migrations add Initial --project .\\Persistence\\ --startup-project ./API/ --output-dir ./Data/Migrations",
	  	],
	  	"description": "crear la migracion"
	},
	  	"updatear la migracion": {
	  	"prefix": "UpdateMigrations",
	  	"body": [
		  	"dotnet ef database update --project ./Persistencia/ --startup-project ./API/",
	  	],
	  	"description": "updatear la migracion"
	},
	  	"configuracion": {
	  	"prefix": "ConfigureCors",
	  	"body": [
		  	"public static void ConfigureCors(this IServiceCollection services) =>",
		  	"	services.AddCors(options =>",
		  	"   {",
		  	"   	options.AddPolicy(\"CorsPolicy\", builder =>",
		  	"   	builder.AllowAnyOrigin()",
		  	"   	.AllowAnyMethod()",
		  	"   	.AllowAnyHeader());",
		  	"   });",
	  	],
	  	"description": "configuracion"
	},
	  	"metodo Post Simple": {
	  	"prefix": "Post Simple",
	  	"body": [
			"[HttpPost]",
    		"[ProducesResponseType(StatusCodes.Status201Created)]",
    		"[ProducesResponseType(StatusCodes.Status400BadRequest)]",
    		"public async Task<ActionResult<$1>> Post($1 data)",
    		"{",
        	"	this.unitOfWork.$1s.Add(data);",
        	"	await unitOfWork.SaveAsync();",
        	"	if (data == null)",
        	"	{",
            "		return BadRequest();",
        	"	}",
        	"	return CreatedAtAction(nameof(Post), new { id = data.Id }, data);",
    		"}"
	  	],
	  	"description": "metodo Post" 
	},
	 	"metodo Post": {
	  	"prefix": "Post Mapping",
	  	"body": [
		  	"[HttpPost]",
		  	"[ProducesResponseType(StatusCodes.Status201Created)]",
		  	"[ProducesResponseType(StatusCodes.Status400BadRequest)]",
		  	"public async Task<ActionResult<$1Dto>> Post($1Dto dataDto)",
		  	"{",
		  	"	var data = mapper.Map<$1>(dataDto);",
		  	"	unitOfWork.$1s.Add(data);",
		  	"	await unitOfWork.SaveAsync();",
		  	"	if(data == null)",
		  	"	{",
		  	"   	return BadRequest();",
		  	"	}",
		  	"	dataDto.Id = data.Id;",
		  	"	return CreatedAtAction(nameof(Post), new {id =dataDto.Id}, dataDto);",
		  	"}"
	  	],
	  	"description": "metodo Put"
	},
		"metodo Post Not Id": {
		"prefix": "PostNotIdMapping",
		"body": [
			"[HttpPost]",
			"[ProducesResponseType(StatusCodes.Status201Created)]",
			"[ProducesResponseType(StatusCodes.Status400BadRequest)]",
			"public async Task<ActionResult<$1Dto>> Post($1Dto dataDto)",
			"{",
			"	var data = mapper.Map<$1>(dataDto);",
			"	unitOfWork.$1s.Add(data);",
			"	try",
			"	{",
			"		await unitOfWork.SaveAsync();",
			"		return CreatedAtAction(nameof(Post), new { /* información para la respuesta */ }, dataDto);",
			"	}",
			"	catch (Exception ex)",
			"	{",
			"   	return BadRequest(\"Error al crear el registro: \" + ex.Message);",
			"	}",
			"}"
		],
		"description": "metodo PostNotIdMapping"
  	}
	  	"metodo Put Simple" : {
		"prefix": "Put Simple",
		"body": [
			"[HttpPut(\"{id}\")]",
			"[ProducesResponseType(StatusCodes.Status200OK)]",
			"[ProducesResponseType(StatusCodes.Status400BadRequest)]",
		   	"[ProducesResponseType(StatusCodes.Status404NotFound)]",
			"public async Task<ActionResult<$1>> Put(int id, [FromBody] $1 data)",
			"{",
			"	if(data == null)",
       		"		{",
           	"			return NotFound();",
       		"		}",
			"	unitOfWork.$1s.Update(data);",
			"	await unitOfWork.SaveAsync();",
			"	return data;",
		   	"}"
		],
	  	"description": "metodo Put Simple"
	},
	  	"metodo Put": {
	  	"prefix": "Put Mapping",
	  	"body": [
		  	"[HttpPut(\"{id}\")]",
		  	"[ProducesResponseType(StatusCodes.Status200OK)]",
		  	"[ProducesResponseType(StatusCodes.Status400BadRequest)]",
		  	"[ProducesResponseType(StatusCodes.Status404NotFound)]",
		  	"public async Task<ActionResult<$1Dto>> Put(int id, [FromBody]$1Dto dataDto)",
			"{",
		  	"   if(dataDto== null)",
		  	"   {",
		  	"       return NotFound();",
		  	"   }",
	  		"   var data = mapper.Map<$1>(dataDto);",
	  		"   unitOfWork.$1s.Update(data);",
	  		"   await unitOfWork.SaveAsync();",
	  		"   return dataDto;",
		  	"}"
	  	],
	  	"description": "metodo Put Mapping"
	},
		"metodo PutNotId": {
		"prefix": "PutNotIdMapping",
		"body": [
			"[HttpPut(\"{id}\")]",
			"[ProducesResponseType(StatusCodes.Status200OK)]",
			"[ProducesResponseType(StatusCodes.Status400BadRequest)]",
			"[ProducesResponseType(StatusCodes.Status404NotFound)]",
			"public async Task<ActionResult<$1Dto>> Put(int id, [FromBody]$1Dto dataDto)",
		  "{",
			"   if(dataDto== null)",
			"   {",
			"       return NotFound();",
			"   }",
			"   var existingData = await unitOfWork.$1s.GetByIdAsync(id);",
			"   if (existingData == null)",
			"   {",
			"   	return NotFound();",
			"	}",
			"	mapper.Map(dataDto, existingData);",
			"	unitOfWork.$1s.Update(existingData);",
			"	await unitOfWork.SaveAsync();",
			"	return dataDto;",
			"}"
		],
		"description": "metodo PutNotIdMapping"
  	}
	  	"metodo Delete Simple": {
		"prefix": "Delete Simple",
		"body": [
			"[HttpDelete(\"{id}\")]",
		  	"[ProducesResponseType(StatusCodes.Status204NoContent)]",
		  	"[ProducesResponseType(StatusCodes.Status404NotFound)]",
		  	"public async Task<IActionResult> Delete(int id)",
			"{",
		  	"   var data = await unitOfWork.$1s.GetByIdAsync(id);",
		  	"   if(data == null)",
		  	"   {",
		  	"      return NotFound();",
		  	"   }",
		  	"   unitOfWork.$1s.Remove(data);",
		  	"   await unitOfWork.SaveAsync();",
		  	"   return NoContent();",
		  	"}"
		],
		"description":"metodo delete Simple"
	},
	  	"metodo Delete": {
	  	"prefix": "Delete Mapping",
	  	"body": [
		  	"[HttpDelete(\"{id}\")]",
		  	"[ProducesResponseType(StatusCodes.Status204NoContent)]",
		  	"[ProducesResponseType(StatusCodes.Status404NotFound)]",
		  	"public async Task<IActionResult> Delete(int id)",
			"{",
		  	"   var data = await unitOfWork.$1s.GetByIdAsync(id);",
		  	"   if(data == null)",
		  	"   {",
		  	"      	return NotFound();",
		  	"   }",
		  	"   unitOfWork.$1s.Remove(data);",
		  	"   await unitOfWork.SaveAsync();",
		  	"   return NoContent();",
		  	"}"
	  	],
	  	"description": "metodo Delete Mapping"
	},
		"metodo DeleteNotId": {
		"prefix": "DeleteNotIdMapping",
		"body": [
			"[HttpDelete(\"{id}\")]",
			"[ProducesResponseType(StatusCodes.Status204NoContent)]",
			"[ProducesResponseType(StatusCodes.Status404NotFound)]",
			"public async Task<IActionResult> Delete(int id)",
		  	"{",
			"   var existingData = await unitOfWork.$1s.GetByIdAsync(id);",
			"   if(existingData == null)",
			"   {",
			"      	return NotFound();",
			"   }",
			"   unitOfWork.$1s.Remove(existingData);",
			"   await unitOfWork.SaveAsync();",
			"   return NoContent();",
			"}"
		],
		"description": "metodo DeleteNotIdMapping"
  	}
	  	"Configuracion configuracion en especifico": {
	  	"prefix": "ControllerEspecifico",
	  	"body": [
		  	"private readonly IUnitOfWork unitOfWork;",
		  	"private readonly  IMapper mapper;",
		  	"",
		  	"public $1Controller(IUnitOfWork unitOfWork, IMapper mapper)",
		  	"{",
		  	"    this.unitOfWork = unitOfWork;",
		  	"    this.mapper = mapper;",
		  	"}"
	  	],
	  	"description": "Configuracion controller en especifico"
	},
	  	"AddAplicacionServices": {
	  	"prefix": "AddAplicacionServices",
	  	"body": [
		  	"public static void AddAplicacionServices(this IServiceCollection services)",
		  	"{",
		  	"	services.AddScoped<IUnitOfWork, UnitOfWork>();",
		  	"}"
	  	],
	  	"description": "AddAplicacionServices"
	},
	  	"ConfigureApiVersioning": {
	  	"prefix": "ConfigureApiVersioning",
	  	"body": [
		  	"public static void ConfigureApiVersioning(this IServiceCollection services)",
		  	"{",
		  	"	services.AddApiVersioning(options =>",
		  	"   {",
		  	"   	options.DefaultApiVersion = new ApiVersion(1, 0);",
		  	"   	options.AssumeDefaultVersionWhenUnspecified = true;",
			"",
			"		options.ApiVersionReader = ApiVersionReader.Combine(",
			"			new QueryStringApiVersionReader(\"ver\"),",
			"			new HeaderApiVersionReader(\"X-Version\")",
			"		);",
		  	"  	});",
		  	"}"
	  	],
	  	"description": "ConfigureApiVersioning"
	},
	  "ConfigureUnitOfWork": {
	  "prefix": "UnitOfWork",
	  "body": [
		  	"private readonly DbAppContext context;",
		  	"//private $1 $2;",
			"",
		  	"public UnitOfWork(DbAppContext _context)",
		  	"{",
		  	"	context = _context;",
		  	"}",
			"",
			"/*",
		  	"public $3 $4",
		  	"{",
		  	"	get{",
		  	"		if($2== null){",
		  	"       $2= new $1(context);",
		  	"   	}",
		  	"	return $2;",
		  	"   }",
		  	"}",
			"*/",
			"",
		  	"public void Dispose()",
		  	"{",
		  	"	context.Dispose();",
		  	"}",
			"",
		  	"public async Task<int> SaveAsync()",
		  	"{",
		  	"	return await context.SaveChangesAsync();",
		  	"}"
	  	],
	  	"description": "ConfigureUnitOfWork"
	},
	  	"RepoID": {
	  	"prefix": "RepoID",
	  	"body": [
		  	"protected readonly DbAppContext _context;",
		  	"",
		  	"public $1Repo(DbAppContext context) : base (context)",
		  	"{",
		  	"	_context = context;",
		  	"}",
		  	"",
		  	"public override async Task<IEnumerable<$1>> GetAllAsync()",
		  	"{",
		  	"	return await _context.$1s",
		  	"		//.Include(p => p.$4)",
		  	"		.ToListAsync();",
		  	"}",
		  	"",
		  	"public override async Task<$1> GetByIdAsync(int id)",
		  	"{",
		  	" 	return await _context.$1s",
		  	"		//.Include(p => p.$4)",
		  	"		.FirstOrDefaultAsync(p =>  p.Id == id);",
		  	"}"
	  	],
	  	"description": "RepoID"
	},
	"RepoString": {
		"prefix": "RepoString",
		"body": [
			"protected readonly DbAppContext _context;",
			"",
			"public $1Repo(DbAppContext context) : base (context)",
			"{",
			"	_context = context;",
			"}",
			"",
			"public override async Task<IEnumerable<$1>> GetAllAsync()",
			"{",
			"	return await _context.$1s",
			"		//.Include(p => p.$4)",
			"		.ToListAsync();",
			"}",
			"",
			"public override async Task<$1> GetByIdAsync(string id)",
			"{",
			" 	return await _context.$1s",
			"		//.Include(p => p.$4)",
			"		.FirstOrDefaultAsync(p =>  p.Id == id);",
			"}"
		],
		"description": "RepoString"
  	},
	  	"añadir metodo ServicesToken pero con la configuracion para los tokens": {
		"prefix": "ServicesToken",
		"body": [
			"public static void AddAplicacionServices(this IServiceCollection services)",
			"{",
			"   services.AddScoped<IPasswordHasher<User>, PasswordHasher<User>>(); ",
			"   services.AddScoped<IUserService, UserService>();",
			"   services.AddScoped<IUnitOfWork, UnitOfWork>();",
			"   services.AddScoped<IAuthorizationHandler, GlobalVerbRoleHandlre>();",
			"}"
		],
		"description": "añadir metodo ServicesToken pero con la configuracion para los tokens"
	},
		"meto para traer el Nombre": {
		"prefix": "GetByUsernameAsync",
		"body": [
			"public async Task<User> GetByUsernameAsync(string username)",
			"{",
			"	return await _context.Users",
			"		.Include(p => p.Rols)",
			"		.FirstOrDefaultAsync(p =>  p.Username.ToLower() == username.ToLower());",
			"}"
		],
		"description": "meto para traer el Nombre"
	},
		"añadir metodo AddAplicacionServices pero con la configuracion para los tokens": {
  		"prefix": "AddAplicacionServicesToken",
  		"body": [
	  		"public static void AddJwt(this IServiceCollection services, IConfiguration configuration)",
	  		"{",
	  		"   services.Configure<JWT>(configuration.GetSection(\"JWT\"));",
			"",
	  		"   services.AddAuthentication(options =>",
			"	{",
			"		options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;",
	  		"		options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;",
			"	}).AddJwtBearer(o =>",
			"		{",
			"			o.RequireHttpsMetadata = false;",
			"			o.SaveToken = false;",
			"			o.TokenValidationParameters = new TokenValidationParameters",
			"			{",
			"				ValidateIssuerSigningKey = true,",
			"				ValidateIssuer = true,",
			"				ValidateAudience = true,",
			"				ValidateLifetime = true,",
			"				ClockSkew = TimeSpan.Zero,",
			"				ValidIssuer = configuration[\"JWT:Issuer\"],",
			"				ValidAudience = configuration[\"JWT:Audience\"],",
			"				IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(configuration[\"JWT:Key\"]))",
			"			};",
			"		});",
	  		"}"
  		],
 		"description": "añadir metodo AddAplicacionServices pero con la configuracion para los tokens"
	},
		"AddRoleDto": {
		"prefix": "AddRoleDto",
		"body": [
			"[Required]",
			"public string Nombre { get; set; }",
			"[Required]",
			"public string Password { get; set; }",
			"[Required]",
			"public string Role { get; set; }"
		],
		"description": "AddRoleDto"
	},
		"DataUserDto": {
		"prefix": "DataUserDto",
		"body": [
			"public int Id { get; set; }",
			"public string Message { get; set; }",
			"public bool IsAuthenticated { get; set; }",
			"public string UserName { get; set; }",
			"public string Email { get; set; }",
			"public List<string> Roles { get; set; }"
			"public string Token { get; set; }"
			"",
			"[JsonIgnore]"
			"public string RefreshToken { get; set; }"
			"public DateTime RefreshTokenExpiration { get; set; }"
		],
		"description": "DataUserDto"
	},
		"LoginDto": {
		"prefix": "LoginDto",
		"body": [
			"[Required]",
			"public string Nombre { get; set; }",
			"[Required]",
			"public string Password { get; set; }"
		],
		"description": "LoginDto"
	},
		"RegisterDto": {
		"prefix": "RegisterDto",
		"body": [
			"[Required]",
			"public string Nombre { get; set; }",
			"[Required]",
			"public string Password { get; set; }",
			"[Required]",
			"public string Email { get; set; }"
		],
		"description": "RegisterDto"
	},
		"RolDto": {
		"prefix": "RolDto",
		"body": [
			"public int Id { get; set; }",
			"public string Nombre { get; set; }"
		],
		"description": "RolDto"
	},
		"UserDto": {
		"prefix": "UserDto",
		"body": [
			"public string Nombre { get; set; }",
			"public string Password { get; set; }",
			"public string Email { get; set; }"
		],
		"description": "UserDto"
	},
		"MappingProfiles": {
		"prefix": "MappingProfiles",
		"body": [
			"CreateMap<Rol, RolDto>().ReverseMap();",
			"CreateMap<User, UserDto>().ReverseMap();",
		],
		"description": "MappingProfiles"
	},
		"CreateMap": {
		"prefix": "CreateMap",
		"body": [
			"CreateMap<$1, $1Dto>().ReverseMap();"
		],
		"description": "CreateMap"
	},
		"ApiException": {
		"prefix": "ApiException  : ApiResponse",
		"body": [
			"public ApiException(int statusCode, string message = null, string details = null) : base(statusCode, message)",
			"{",
			"	Details = details;",
			"}",
			"",
			"public string Details { get; set; }"
		],
		"description": "ApiException"
	},
		"ApiResponse": {
		"prefix": "ApiResponse",
		"body": [
			"public int StatusCode { get; set; }",
			"public string Message { get; set; }",
			"",
			"public ApiResponse(int statusCode, string message = null)",
			"{",
			"	StatusCode = statusCode;",
			"	Message = message ?? GetDefaultMessage(statusCode);",
			"}",
			"public string Details { get; set; }"
			"",
			"public ApiResponse()",
			"{}",
			"",
			"private string GetDefaultMessage(int statusCode)",
			"{",
			"	return statusCode switch",
			"	{",
			"		400 => \"Has realizado una petición incorrecta.\",",
			"		401 => \"Usuario no autorizado.\",",
			"		404 => \"El recurso que has intentado solicitar no existe.\",",
			"		405 => \"Este método HTTP no está permitido en el servidor.\"",
			"		500 => \"Error en el servidor. No eres tú, soy yo. Comunícate con el administrador XD.\",",
			"		_ => throw new NotImplementedException()",
			"	};",
			"}",
		],
		"description": "ApiResponse"
	},
		"Authorization": {
		"prefix": "Authorization",
		"body": [
			"public enum Roles",
			"{",
			"	Administrator,",
			"	Empleado",
			"}",
			"public const Roles rol_default = Roles.Empleado;"
		],
		"description": "Authorization"
	},
		"ExceptionMiddleware": {
		"prefix": "ExceptionMiddleware",
		"body": [
			"private readonly RequestDelegate _next;",
			"private readonly ILogger<ExceptionMiddleware> _logger;",
			"private readonly IHostEnvironment _env;",
			"",
			"public ExceptionMiddleware(RequestDelegate next, ILogger<ExceptionMiddleware> logger, IHostEnvironment env)",
			"{",
			"	_next = next;",
			"	_logger = logger;",
			"	_env = env;",
			"}",
			"",
			"public async Task InvokeAsync(HttpContext context)",
			"{",
			"	try",
			"	{",
			"		await _next(context);",
			"	}",
			"	catch (Exception ex)",
			"	{",
			"	var statusCode = (int)HttpStatusCode.InternalServerError;",
			"",
			"	_logger.LogError(ex, ex.Message);",
			"	context.Response.ContentType = "application/json";",
			"	context.Response.StatusCode = statusCode;",
			"",
			"	var response = _env.IsDevelopment()",
			"					? new ApiException(statusCode, ex.Message, ex.StackTrace.ToString()) : new ApiException(statusCode);",
			"",
			"	var options = new JsonSerializerOptions",
			"	{",
			"		PropertyNamingPolicy = JsonNamingPolicy.CamelCase",
			"	};",
			"	var json = JsonSerializer.Serialize(response, options);",
			"	await context.Response.WriteAsync(json);"
			"	}",
			"}"
		],
		"description": "ExceptionMiddleware"
	},
		"JWT": {
		"prefix": "JWT",
		"body": [
			"public string Key { get; set; }",
			"public string Issuer { get; set; }",
			"public string Audience { get; set; }",
			"public double DurationInMinutes { get; set; }"
		],
		"description": "JWT"
	},
		"Pager": {
		"prefix": "Pager<T> where T : class",
		"body": [
			"public string Search { get; set; }",
			"public int PageIndex { get; set; }",
			"public int PageSize { get; set; }",
			"public int Total { get; set; }",
			"public List<T> Registers { get; set; }",
			"",
			"public Pager()",
			"{}",
			"",
			"public Pager(List<T> registers, int total, int pageIndex, int pageSize, string search)",
			"{",
			"	Registers = registers;",
			"	Total = total;",
			"	PageIndex = pageIndex;",
			"	PageSize = pageSize;",
			"	Search = search;",
			"}",
			"",
			"public int TotalPages",
			"{",
			"	get",
			"	{",
			"		return (int)Math.Ceiling(Total / (double)PageSize);",
			"	}",
			"	set",
			"	{",
			"		this.TotalPages = value;",
			"	}",
			"}",
			"",
			"public bool HasPreviousPage",
			"{",
			"	get",
			"	{",
			"		return (PageIndex > 1);",
			"	}",
			"	set",
			"	{",
			"		this.HasPreviousPage = value;",
			"	}",
			"}",
			"",
			"public bool HasNextPage",
			"{",
			"	get",
			"	{",
			"		return (PageIndex < TotalPages);",
			"	}",
			"	set",
			"	{",
			"		this.HasNextPage = value;",
			"	}",
			"}"
		],
		"description": "Pager"
	},
		"Params": {
		"prefix": "Params",
		"body": [
			"private int _pageSize = 5;",
			"private const int MaxPageSize = 50;",
			"private int _pageIndex = 1;",
			"private string _search;",
			"",
			"public int PageSize",
			"{",
			"	get => _pageSize;",
			"	set => _pageSize = (value > MaxPageSize) ? MaxPageSize : value;",
			"}",
			"",
			"public int PageIndex",
			"{",
			"	get => _pageIndex;",
			"	set => _pageIndex = (value <= 0) ? 0 : value;",
			"}",
			"",
			"public string Search",
			"{",
			"	get => _search;",
			"	set => _search = (!string.IsNullOrEmpty(value)) ? value.ToLower() : "";",
			"}"
		],
		"description": "Params"
	},
		"ApiVersion": {
		"prefix": "ApiVersion",
		"body": [
			"[ApiVersion(\"1.0\")]",
			"[ApiVersion(\"1.1\")]"
		],
		"description": "ApiVersion"
	},
	"IUserService": {
		"prefix": "IUserService",
		"body": [
			"Task<string> RegisterAsync(RegisterDto model);",
			"Task<DataUserDto> GetTokenAsync(LoginDto model);",
			"Task<string> AddRoleAsync(AddRoleDto model);",
			"Task<DataUserDto> RefreshTokenAsync(string refreshToken);"
		],
		"description": "IUserService"
	},
	"UserService": {
		"prefix": "UserService  : IUserService",
		"body": [
			"private readonly JWT _jwt;",
			"private readonly IUnitOfWork _unitOfWork;",
			"private readonly IPasswordHasher<User> _passwordHasher;",
			"public UserService(IUnitOfWork unitOfWork, IOptions<JWT> jwt, IPasswordHasher<User> passwordHasher)",
			"{",
			"	_jwt = jwt.Value;",
			"	_unitOfWork = unitOfWork;",
			"	_passwordHasher = passwordHasher;",
			"}",
			"",		
			"public async Task<string> RegisterAsync(RegisterDto registerDto)",
			"{",
			"	var user = new User",
			"{",
			"	Nombre = registerDto.Nombre,",
			"	Email = registerDto.Email",
			"};",
			"",		
			"user.Password = _passwordHasher.HashPassword(user, registerDto.Password);",
			"",
			"var existingUser = _unitOfWork.Users",
			"						.Find(u => u.Nombre.ToLower() == registerDto.Nombre.ToLower())",
			"						.FirstOrDefault();",
			"",		
			"if (existingUser == null)",
			"{",
			"	var rolDefault = _unitOfWork.Roles",
			"						.Find(u => u.Nombre == Authorization.rol_default.ToString())",
			"						.First();",
			"	try",
			"		{",
			"			user.Rols.Add(rolDefault);",
			"			_unitOfWork.Users.Add(user);",
			"			await _unitOfWork.SaveAsync();",
			"",
			"			return $\"User  {registerDto.Nombre} has been registered successfully\";",
			"		}",
			"		catch (Exception ex)",
			"		{",
			"			var message = ex.Message;",
			"			return $\"Error: {message}\";",
			"		}",
			"	}",
			"	else",
			"	{",
			"		return $\"User {registerDto.Nombre} already registered.\";",
			"	}",
			"}",
			"",
			"public async Task<DataUserDto> GetTokenAsync(LoginDto model)",
			"{",
			"	DataUserDto dataUserDto = new DataUserDto();",
			"	var user = await _unitOfWork.Users",
			"		.GetByUsernameAsync(model.Nombre);",
			"",
			"if (user == null)",
			"{",
			"	dataUserDto.IsAuthenticated = false;",
			"	dataUserDto.Message = $\"User does not exist with username {model.Nombre}.\";",
			"	return dataUserDto;",
			"}",
			"",
			"var result = _passwordHasher.VerifyHashedPassword(user, user.Password, model.Password);",
			""	,	
			"if (result == PasswordVerificationResult.Success)",
			"{",
			"	dataUserDto.IsAuthenticated = true;",
			"	JwtSecurityToken jwtSecurityToken = CreateJwtToken(user);",
			"	dataUserDto.Token = new JwtSecurityTokenHandler().WriteToken(jwtSecurityToken);",
			"	dataUserDto.UserName = user.Nombre;",
			"	dataUserDto.Roles = user.Rols",
			"					.Select(u => u.Nombre)",
			"					.ToList();",
			"",
			"	if (user.RefreshTokens.Any(a => a.IsActive))",
			"	{",
			"		var activeRefreshToken = user.RefreshTokens.Where(a => a.IsActive == true).FirstOrDefault();",
			"		dataUserDto.RefreshToken = activeRefreshToken.Token;",
			"		dataUserDto.RefreshTokenExpiration = activeRefreshToken.Expires;",
			"	}",
			"	else",
			"	{",
			"		var refreshToken = CreateRefreshToken();",
			"		dataUserDto.RefreshToken = refreshToken.Token;",
			"		dataUserDto.RefreshTokenExpiration = refreshToken.Expires;",
			"		user.RefreshTokens.Add(refreshToken);",
			"		_unitOfWork.Users.Update(user);",
			"		await _unitOfWork.SaveAsync();",
			"	}",
			"		return dataUserDto;",
			"	}",
			"	dataUserDto.IsAuthenticated = false;",
			"	dataUserDto.Message = $\"Credenciales incorrectas para el usuario {user.Nombre}.\";",
			"	return dataUserDto;",
			"}",
			"",
			"public async Task<string> AddRoleAsync(AddRoleDto model)",
			"{",
			"",		
			"var user = await _unitOfWork.Users",
			"					.GetByUsernameAsync(model.Nombre);",
			"if (user == null)",
			"{",
			"	return $\"User {model.Nombre} does not exists.\";",
			"}",
			"",		
			"var result = _passwordHasher.VerifyHashedPassword(user, user.Password, model.Password);",
			"",		
			"if (result == PasswordVerificationResult.Success)",
			"{",
			"	var rolExists = _unitOfWork.Roles",
			"						.Find(u => u.Nombre.ToLower() == model.Role.ToLower())",
			"						.FirstOrDefault();",
			"",		
			"	if (rolExists != null)",
			"	{",
			"		var userHasRole = user.Rols.Any(u => u.Id == rolExists.Id);",
			"",		
			"		if (userHasRole == false)",
			"		{",
			"			user.Rols.Add(rolExists);",
			"			_unitOfWork.Users.Update(user);",
			"			await _unitOfWork.SaveAsync();",
			"		}"		
			"			return $\"Role {model.Role} added to user {model.Nombre} successfully.\";",
			"		}",
			"			return $\"Role {model.Role} was not found.\";",
			"		}",
			"	return $\"Invalid Credentials\";",
			"}",
			"",		
			"public async Task<DataUserDto> RefreshTokenAsync(string refreshToken)",
			"{",
			"	var dataUserDto = new DataUserDto();",
			"",		
			"	var usuario = await _unitOfWork.Users",
			"						.GetByRefreshTokenAsync(refreshToken);",
			"",		
			"if (usuario == null)",
			"{",
			"	dataUserDto.IsAuthenticated = false;",
			"	dataUserDto.Message = $\"Token is not assigned to any user.\";",
			"	return dataUserDto;",
			"}",
			"",		
			"var refreshTokenBd = usuario.RefreshTokens.Single(x => x.Token == refreshToken);",
			"",		
			"if (!refreshTokenBd.IsActive)",
			"{",
			"	dataUserDto.IsAuthenticated = false;",
			"	dataUserDto.Message = $\"Token is not active.\";",
			"	return dataUserDto;",
			"}",
			"refreshTokenBd.Revoked = DateTime.UtcNow;",
			"var newRefreshToken = CreateRefreshToken();",
			"usuario.RefreshTokens.Add(newRefreshToken);",
			"_unitOfWork.Users.Update(usuario);",
			"await _unitOfWork.SaveAsync();",
			"dataUserDto.IsAuthenticated = true;",
			"JwtSecurityToken jwtSecurityToken = CreateJwtToken(usuario);",
			"dataUserDto.Token = new JwtSecurityTokenHandler().WriteToken(jwtSecurityToken);",
			"/* dataUserDto.Email = usuario.Email; */",
			"dataUserDto.UserName = usuario.Nombre;",
			"dataUserDto.Email = usuario.Email;",
			"dataUserDto.Roles = usuario.Rols",
			"						.Select(u => u.Nombre)",
			"						.ToList();",
			"	dataUserDto.RefreshToken = newRefreshToken.Token;",
			"	dataUserDto.RefreshTokenExpiration = newRefreshToken.Expires;",
			"	return dataUserDto;",
			"}",
			"",		
			"private RefreshToken CreateRefreshToken()",
			"{",
			"	var randomNumber = new byte[32];",
			"	using (var generator = RandomNumberGenerator.Create())",
			"	{",
			"		generator.GetBytes(randomNumber);",
			"		return new RefreshToken",
			"			{",
			"				Token = Convert.ToBase64String(randomNumber),",
			"				Expires = DateTime.UtcNow.AddDays(10),",
			"				Created = DateTime.UtcNow",
			"			};",
			"	}",
			"}",
			"",		
			"private JwtSecurityToken CreateJwtToken(User user)",
			"{",
			"	var roles = user.Rols;",
			"	var roleClaims = new List<Claim>();",
			"	foreach (var role in roles)",
			"	{",
			"		roleClaims.Add(new Claim(\"roles\", role.Nombre));",
			"	}",
			"	var claims = new[]",
			"	{",
			"		new Claim(JwtRegisteredClaimNames.Sub, user.Nombre),",
			"		new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),",
			"		new Claim(JwtRegisteredClaimNames.Email, user.Email),",
			"		new Claim(\"uid\", user.Id.ToString())",
			"	}",
			"	.Union(roleClaims);",
			"	var symmetricSecurityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwt.Key));",
			"	var signingCredentials = new SigningCredentials(symmetricSecurityKey, SecurityAlgorithms.HmacSha256);",
			"	var jwtSecurityToken = new JwtSecurityToken(",
			"	issuer: _jwt.Issuer,",
			"	audience: _jwt.Audience,",
			"	claims: claims,",
			"	expires: DateTime.UtcNow.AddMinutes(_jwt.DurationInMinutes),",
			"	signingCredentials: signingCredentials);",
			"	return jwtSecurityToken;",
			"}"
		],
		"description": "UserService"
	},
		"TaskUser": {
		"prefix": "TaskUser",
		"body": [
			"public async Task<User> GetByRefreshTokenAsync(string refreshToken)",
			"{",
			"	return await _context.Users",
			"			.Include(u => u.Rols)",
			"			.Include(u => u.RefreshTokens)",
			"			.FirstOrDefaultAsync(u => u.RefreshTokens.Any(t => t.Token == refreshToken));",
			"}",
			"",
			"public async Task<User> GetByUsernameAsync(string username)",
			"{",
			"	return await _context.Users",
			"		.Include(u => u.Rols)",
			"		.Include(u => u.RefreshTokens)",
			"		.FirstOrDefaultAsync(u => u.Nombre.ToLower() == username.ToLower());",
			"}"
		],
		"description": "TaskUser"
	},
		"TaskIUser": {
		"prefix": "TaskIUser",
		"body": [
			"Task<User> GetByUsernameAsync(string username);",
			"Task<User> GetByRefreshTokenAsync(string username);"
		],
		"description": "TaskIUser"
	},
		"UserEntity": {
		"prefix": "UserEntity",
		"body": [
			"public string Nombre { get; set; }",
			"public string Email { get; set; }",
			"public string Password { get; set; }",
			"public ICollection<Rol> Rols { get; set; } = new HashSet<Rol>();",
			"public ICollection<RefreshToken> RefreshTokens { get; set; } = new HashSet<RefreshToken>();",
			"public ICollection<UserRol> UserRols { get; set; }"
		],
		"description": "UserEntity"
	},
	"RolEntity": {
		"prefix": "RolEntity",
		"body": [
			"public string Nombre { get; set; }",
			"public ICollection<User> Users { get; set; } = new HashSet<User>();",
			"public ICollection<UserRol> UserRols { get; set; }"
		],
		"description": "RolEntity"
	},
	"UserRolEntity": {
		"prefix": "UserRolEntity",
		"body": [
			"public int IdUserFK { get; set; }",
			"public User User { get; set; }",
			"public int IdRolFK { get; set; }",
			"public Rol Rol { get; set; }"
		],
		"description": "UserRolEntity"
	},
	"RefreshToken": {
		"prefix": "RefreshToken",
		"body": [
			"public int IdUserFK { get; set; }",
			"public User User { get; set; }",
			"public string Token { get; set; }",
			"public DateTime Expires { get; set; }",
			"public bool IsExpired => DateTime.UtcNow >= Expires;",
			"public DateTime Created { get; set; }",
			"public DateTime? Revoked { get; set; }",
			"public bool IsActive => Revoked == null && !IsExpired;"
		],
		"description": "RefreshToken"
	},
	"UserRefresh": {
		"prefix": "UserRefresh",
		"body": [
			"builder.HasMany(p => p.RefreshTokens)",
            "	.WithOne(p => p.User)",
            "	.HasForeignKey(p => p.IdUserFK);"
		],
		"description": "UserRefresh"
	},
	"DateUnique": {
		"prefix": "DateUnique",
		"body": [
			"modelBuilder.Entity<YourEntity>().HasIndex(e => e.YourProperty).IsUnique();"
		],
		"description": "DateUnique"
	},
	"SeedAsync": {
		"prefix": "SeedAsync",
		"body": [
			"public static async Task SeedAsync(DbAppContext context, ILoggerFactory loggerFactory)",
			"{",
			"	try",
			"	{",
			"		// \"*\" Inicio de las insersiones en la Database",
			"		var ruta = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);",
			"",
			"		if (!context.Users.Any())",
			"		{",
			"			using (var reader = new StreamReader(ruta + @\"/Data/Csv/User.csv\"))",
			"			{",
			"				using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))",
			"				{",
			"					var list = csv.GetRecords<User>();",
			"					context.Users.AddRange(list);",
			"					await context.SaveChangesAsync();",
			"				}",
			"			}",
			"",
			"		}",
			"",
			"		if (!context.UserRols.Any())",
			"		{",
			"			using (var reader = new StreamReader(ruta + @\"\\Data\\Csv\\UserRol.csv\"))",
			"			{",
			"				using (var csv = new CsvReader(reader, new CsvConfiguration(CultureInfo.InvariantCulture)",
			"				{",
			"					HeaderValidated = null,",
			"					MissingFieldFound = null",
			"				}))",
			"				{",
			"					var list = csv.GetRecords<UserRol>();",
			"					List<UserRol> entidad = new List<UserRol>();",
			"					foreach (var item in list)",
			"					{",
			"						entidad.Add(new UserRol",
			"						{",
			"							IdUserFK = item.IdUserFK,",
			"							IdRolFK = item.IdRolFK",
			"						});",
			"					}",
			"					context.UserRols.AddRange(entidad);",
			"					await context.SaveChangesAsync();",
			"				}",
			"			}",
			"		}",
			"		// \"*\" Fin de las insersiones en la Database",
			"	}",
			"	catch (Exception ex)",
			"	{",
			"		var logger = loggerFactory.CreateLogger<DbAppContext>();",
			"		logger.LogError(ex.Message);",
			"	}",
			"}",
		],
		"description": "SeedAsync"
	},
	"SeedRolesAsync": {
		"prefix": "SeedRolesAsync",
		"body": [
			"public static async Task SeedRolesAsync(DbAppContext context, ILoggerFactory loggerFactory)",
			"{",
			"	try",
			"	{",
			"		if (!context.Rols.Any())",
			"		{",
			"			var roles = new List<Rol>()",
			"			{",
			"				new Rol{Id=1, Nombre=\"Administrador\"},",
			"				new Rol{Id=2, Nombre=\"Empleado\"},",
			"			};",
			"		context.Rols.AddRange(roles);",
			"		await context.SaveChangesAsync();",
			"		}",
			"	}",
			"	catch (Exception ex)",
			"	{",
			"		var logger = loggerFactory.CreateLogger<DbAppContext>();",
			"		logger.LogError(ex.Message);",
			"	}",
			"}"
		],
		"description": "SeedRolesAsync"
	},
	"Authorize": {
		"prefix": "Authorize",
		"body": [
			"[Authorize(Roles = \"Administrador\")]"
		],
		"description": "Authorize"
	},
	"MapToApiVersion": {
		"prefix": "MapToApiVersion",
		"body": [
			"[MapToApiVersion(\"1.0\")]"
		],
		"description": "MapToApiVersion"
	},
	"MetodoRegister": {
		"prefix": "MetodoRegister",
		"body": [
			"[HttpPost(\"register\")]",
			"[Authorize(Roles = \"Administrador\")]",
			"public async Task<ActionResult> RegisterAsync(RegisterDto model)",
			"{",
			"	var result = await _userservice.RegisterAsync(model);",
			"	return Ok(result);",
			"}"
		],
		"description": "MetodoRegister"
	},
	"MetodoToken": {
		"prefix": "MetodoToken",
		"body": [
			"[HttpPost(\"token\")]",
			"public async Task<IActionResult> GetTokenAsync(LoginDto model)",
			"{",
			"	var result = await _userservice.GetTokenAsync(model);",
			"	SetRefreshTokenInCookie(result.RefreshToken);",
			"	return Ok(result);",
			"}"
		],
		"description": "MetodoToken"
	},
	"MetodoAddRole": {
		"prefix": "MetodoAddRole",
		"body": [
			"[HttpPost(\"addrole\")]",
			"[Authorize(Roles = \"Administrador\")]",
			"public async Task<IActionResult> AddRoleAsync(AddRoleDto model)",
			"{",
			"	var result = await _userservice.AddRoleAsync(model);",
			"	return Ok(result);",
			"}"
		],
		"description": "MetodoAddRole"
	},
	"MetodoRefreshToken": {
		"prefix": "MetodoRefreshToken",
		"body": [
			"[HttpPost(\"refresh-token\")]",
			"[Authorize]",
			"public async Task<IActionResult> RefreshToken()",
			"{",
			"	var refreshToken = Request.Cookies[\"refreshToken\"];",
			"	var response = await _userservice.RefreshTokenAsync(refreshToken);",
			"	if (!string.IsNullOrEmpty(response.RefreshToken))",
			"		SetRefreshTokenInCookie(response.RefreshToken);",
			"	return Ok(response);",
			"}"
		],
		"description": "MetodoRefreshToken"
	},
	"SetRefreshTokenInCookie": {
		"prefix": "SetRefreshTokenInCookie",
		"body": [
			"private void SetRefreshTokenInCookie(string refreshToken)",
			"{",
			"	if (!string.IsNullOrEmpty(refreshToken))",
			"	{",
			"		var cookieOptions = new CookieOptions",
			"		{",
			"			HttpOnly = true,",
			"			Expires = DateTime.UtcNow.AddDays(10),",
			"		};",
			"		Response.Cookies.Append(\"refreshToken\", refreshToken, cookieOptions);",
			"	}",
			"	else",
			"	{",
			"		// Se pueden manejar otras respuestas",
			"	}",
			"}",
		],
		"description": "SetRefreshTokenInCookie"
	},
	"ConstructorUserController": {
		"prefix": "ConstructorUserController",
		"body": [
			"private readonly IUserService _userservice;",
			"private readonly IUnitOfWork unitOfWork;",
			"private readonly IMapper mapper;",
			"",
			"public UserController(IUserService userService, IUnitOfWork unitOfWork, IMapper mapper)",
			"{",
			"	_userservice = userService;",
			"	this.unitOfWork = unitOfWork;",
			"	this.mapper = mapper;",
			"}"
		],
		"description": "ConstructorUserController"
	},
	"ComandoDbFirst": {
		"prefix": "ComandoDbFirst",
		"body": [
			"dotnet ef dbcontext scaffold \"server=localhost;user=root;password=1122809631;database=jardineria\" Pomelo.EntityFrameworkCore.MySql -s API -p Persistence --context DbFirstContext --context-dir Data --output-dir Entities"
		],
		"description": "ComandoDbFirst"
	},
	"Database Connection Strings": {
		"prefix": "dbconn",
		"body": [
			"ConnectionStrings"": {"
				"ConexSqlServer": "Data Source=localhost\\sqlexpress;Initial Catalog=Db;Integrated Security=true",
				"ConexMySql": "Server=localhost;User=root;Database=PostDb;Password=;"
			  "},"
			  "description": "Configura las conexiones con las bases de datos"
		],
		"description": "ComandoStringsConnections"
	}
}
